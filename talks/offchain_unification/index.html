<!doctype html>
<html lang="en">

	<head>
		<meta charset="utf-8">

		<title>Verifying Offchain Computations</title>

		<meta name="author" content="Christian Reitwiessner">

		<meta name="apple-mobile-web-app-capable" content="yes" />
		<meta name="apple-mobile-web-app-status-bar-style" content="black-translucent" />

		<meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no, minimal-ui">

		<link rel="stylesheet" href="../reveal.js/css/reveal.css">
		<link rel="stylesheet" href="../reveal.js/css/theme/simple.css" id="theme">

		<!-- Code syntax highlighting -->
		<link rel="stylesheet" href="../reveal.js/lib/css/zenburn.css">

		<!--[if lt IE 9]>
		<script src="lib/js/html5shiv.js"></script>
		<![endif]-->
		<script>
			var link = document.createElement( 'link' );
			link.rel = 'stylesheet';
			link.type = 'text/css';
			link.href = window.location.search.match( /print-pdf/gi ) ? 'css/print/pdf.css' : 'css/print/paper.css';
			document.getElementsByTagName( 'head' )[0].appendChild( link );
		</script>
<style type="text/css">
@font-face {
	font-family: PTSans;
	src: url('./pt-sans-regular.woff') format('woff');
	font-weight: normal;
	font-style: normal;
}
body, .reveal {
	font-family: PTSans, Arial, sans-serif;
}
.reveal .slides {
	text-align: left;
}
.reveal pre {
  width: inherit;
}
.reveal table th, .reveal table td {
    border-bottom: none;
}
.reveal h1, .reveal h2, .reveal h3, .reveal h4, .reveal h5, .reveal h6 {
	text-align: center;
	text-transform: none;
	font-family: PTSans, Arial, sans-serif;
}
p { text-align: left; }
.reveal .slides section .fragment.appear {
  opacity: 0;
  display: none;
}
.reveal .slides section .fragment.appear.visible {
  opacity: 1;
  display: block;
}
.reveal .slides section .fragment.appear-once {
  opacity: 0;
  display: none;
}
.reveal .slides section .fragment.appear-once.current-fragment {
  opacity: 1;
  display: block;
}
.backgrounds {
  -webkit-filter: opacity(0%);
  -moz-filter: opacity(0%);
  -o-filter: opacity(0%);
  -ms-filter: opacity(0%);
  filter: opacity(0%);
}
html.blurStrong .backgrounds {
  -webkit-filter: opacity(20%);
  -moz-filter: opacity(20%);
  -o-filter: opacity(20%);
  -ms-filter: opacity(20%);
  filter: opacity(20%);
}
html.blurLight .backgrounds {
  -webkit-filter: opacity(60%);
  -moz-filter: opacity(60%);
  -o-filter: opacity(60%);
  -ms-filter: opacity(60%);
  filter: opacity(60%);
}
html.noBlur .backgrounds {
  -webkit-filter: none;
  -moz-filter: none;
  -o-filter: none;
  -ms-filter: none;
  filter: none;
}
</style>

	</head>

	<body>

		<div class="reveal">

			<!-- Any section element inside of this container is displayed as a slide -->
			<div class="slides">
 
<section data-markdown><script type="text/template">
## Verifying Offchain Computations

<br/>
<br/>

Off the Chain - Berlin - 2018-06-30

<small>
Christian Reitwiessner <br/>
Ethereum Foundation <br/>
@ethchris   github.com/chriseth   chris@ethereum.org
</small>

</script></section>

<section data-markdown><script type="text/template">
### What is Computation?

- Verifying cryptographic signature
- DEX: Finding optimal price assignment for orders
- Computing new state given current state and sequence of transactions
- Verifying transition in state channel

Fixed, formalized procedure applied to certain inputs that yields certain outputs

</script></section>

<section data-markdown><script type="text/template">
### Types of Computations / Problems

- Most general: Input maps to output, both arbitrary size.
- Verification problem: Output is binary (true / false)
- Search problem: 
- Optimization problem: 
- Witness / Advice:
</script></section>

<section>
<h3>Advice</h3>
<p>Computation task: Find Waldo in the next slide.</p>
<center>
<img src="./waldo.png" style="margin: auto; border: none; height: 200px;"/>
<br/>Waldo
</center>
</section>

<section data-background="waldo.jpg" data-state="noBlur">
</section>

<section data-background="waldo2.jpg" data-state="noBlur">
</section>

<section data-markdown><script type="text/template">
### The Power of Advice / Witnesses

 - cannot be trusted, has to be checked
 - can speed up computations (only verification/optimization type) tremendously
 - connection to zero knowledge
</script></section>
    
<section data-markdown><script type="text/template">
What is the connection to blockchain?
</script></section>

<section data-markdown><script type="text/template">
```TypeScript
contract Multisig {
  address[] owners;
  function removeOwner(address o) public {
    uint pos = findOwnerPos(o);


    // Replace by last one and remove
    owners[pos] = owners[owners.length - 1];
    owners.pop();
  }
  function findOwnerPos(address o) public returns (uint) {
    for (uint i = 0; i < owners.length; i++)
      if (owners[i] == o)
        return i;
    revert("Owner not found.");
  }
}
```
</script></section>

<section data-markdown><script type="text/template">
```TypeScript
contract Multisig {
  address[] owners;
  function removeOwner(address o, uint pos) public {
    // uint pos = findOwnerPos(o);


    // Replace by last one and remove
    owners[pos] = owners[owners.length - 1];
    owners.pop();
  }
  function findOwnerPos(address o) public returns (uint) {
    for (uint i = 0; i < owners.length; i++)
      if (owners[i] == o)
        return i;
    revert("Owner not found.");
  }
}
```
</script></section>

<section data-markdown><script type="text/template">
```TypeScript
contract Multisig {
  address[] owners;
  function removeOwner(address o, uint pos) public {
    // uint pos = findOwnerPos(o);

    require(owners[pos] == o);
    // Replace by last one and remove
    owners[pos] = owners[owners.length - 1];
    owners.pop();
  }
  function findOwnerPos(address o) public returns (uint) {
    for (uint i = 0; i < owners.length; i++)
      if (owners[i] == o)
        return i;
    revert("Owner not found.");
  }
}
```
</script></section>

<section data-markdown><script type="text/template">
```TypeScript
contract Multisig {
  address[] owners;
  function removeOwner(address o, uint pos [ = findOwnerPos(o) ]) public {
    // uint pos = findOwnerPos(o);
    
    require(owners[pos] == o);
    // Replace by last one and remove
    owners[pos] = owners[owners.length - 1];
    owners.pop();
  }
  function findOwnerPos(address o) public returns (uint) {
    for (uint i = 0; i < owners.length; i++)
      if (owners[i] == o)
        return i;
    revert("Owner not found.");
  }
}
```
</script></section>

<section data-markdown><script type="text/template">
```TypeScript
contract Multisig {
  address[] owners;
  function removeOwner(address o, uint pos [ = findOwnerPos(o) ]) public {
    // uint pos = findOwnerPos(o);
    if (owners[pos] != o) pos = findOwnerPos(o);
    require(owners[pos] == o);
    // Replace by last one and remove
    owners[pos] = owners[owners.length - 1];
    owners.pop();
  }
  function findOwnerPos(address o) public returns (uint) {
    for (uint i = 0; i < owners.length; i++)
      if (owners[i] == o)
        return i;
    revert("Owner not found.");
  }
}
```
</script></section>

<section data-markdown><script type="text/template">
- on-chain components only verify, should do not compute
- language features to help computing advice
  1. avoids double implementations
  2. on-chain fall-back might still be a good idea (race conditions!)
- advice cannot be trusted, full verification necessary
</script></section>


<section>
<h3>Scalability in Ethereum</h3>
<ul>
<li><b>Casper</b>: scale state space and transactions via <b>sharding</b></li>
<li><b>zkSNARKs</b>: scale computations by encoding them as polynomials on elliptic curves</li>
</ul>
<p>Not practical yet, requires fork (soon for zkSNARKs).</p>

<p>Workaround: Blockchain only central hub or <b>supreme court</b>.</p>
<ul>
<li><b>Raiden</b>: scale transactions via <b>state channels</b></li>
<li><b>TrueBit</b>: scale computations via <b>interactive verification</b></li>
</ul>
</section>

<section data-markdown><script type="text/template">
### How to Scale Computation?

- only few people perform computation off-chain
- only post input and output to blockchain
- if anyone disagrees, they go to court (blockchain)
- on-chain settling must be magnitudes faster

</script></section>

<section data-markdown><script type="text/template">
### Wrap-Up

- Difference between "search" and "processing" computations
- Blockchains can be used to verify computations, but are extremely limited
- TrueBit scales this limitation with unanimous consensus

</script></section>



<section data-markdown><script type="text/template">
realize that it is only "almost" -> P/NP? / interactive games

diagram of blockchain in the middle as central verifier with multiple provers outside

can take this to the extreme and only put single state hash on chain,
if authenticated via signatures (simple two-person state channel), you do not even have to verify correctness,
only need to verify signature

Problem: data structures have to be re-generated by the client off chain
(very problematic if you have to generated merkle proofs. Example: zcash)

Because of these two problems (data structure regeneration and
redundant off-chain and on-chain code),
off-chain scaling solutions have big overhead.

</script></section>

<section data-markdown><script type="text/template">
  Problem statement

  Scaling by moving stuff off the chain - still needs to be correct

  NP? snarks?

  Searching versus finding? (from the zero knowledge talk)

  Computing off chain, verifying on chain. State channels, even worse with snarks and stuff.

  snarks / starks?

</script></section>
</div>

		</div>

		<script src="../reveal.js/lib/js/head.min.js"></script>
		<script src="../reveal.js/js/reveal.js"></script>

		<script>
			// Full list of configuration options available at:
			// https://github.com/hakimel/reveal.js#configuration
			Reveal.initialize({
				controls: true,
				progress: true,
				history: true,
				center: false,

				transition: 'none', // none/fade/slide/convex/concave/zoom

				// Optional reveal.js plugins
				dependencies: [
					{ src: '../reveal.js/lib/js/classList.js', condition: function() { return !document.body.classList; } },
					{ src: '../reveal.js/plugin/markdown/marked.js', condition: function() { return !!document.querySelector( '[data-markdown]' ); } },
					{ src: '../reveal.js/plugin/markdown/markdown.js', condition: function() { return !!document.querySelector( '[data-markdown]' ); } },
					{ src: '../reveal.js/plugin/highlight/highlight.js', async: true, callback: function() { hljs.initHighlightingOnLoad(); } },
					{ src: '../reveal.js/plugin/zoom-js/zoom.js', async: true },
					{ src: '../reveal.js/plugin/notes/notes.js', async: true }
				]
			});

		</script>

	</body>
</html>
